## 객체 복사
- 객체 인스턴스를 참조하지 않고, **새로운 객체 인스턴스로 복사해야 하는 경우** 필요한 프로토콜 소개
- 얕은 복사가 아닌 **깊은 복사를 위한 아카이브 방식** 소개

### 1. NSCopying 계열 프로토콜
- <NSCopying> : 읽기만 가능
- <NSMutableCopying> : 읽고 쓰기 가능

### 2. 얕은 복사 vs. 깊은 복사
- 얕은복사: 참조하는 포인터에 있는 주소값만 복사하는 방식
	- NSArray 처럼 객체 내부에 다른 객체를 포함하는 경우에는 객체 복사 시 주의해야 한다.  내부 객체의 메모리 주소를 포인터 변수로 접근하는 것뿐이기 때문이다. 즉, NSArray 객체를 복사한다고 해서 내부 객체도 동일한 복사본이 생기는 것이 아니라, 참조하는 포인터에 있는 주소값만 복사한다.
- 깊은복사: 내부 객체까지 모두 새롭게 생성한다.
	- 우선 얕은 복사를 한 상태에서 형성된 **객체 그래프의 하위 노드부터 탐색(DFS, 깊이우선 탐색)하며 새로운 객체를 만들어 복사**하는 식으로 모든 객체를 복사한다.
	- 하지만 이렇게 깊이 우선 탐색(DFS) 시, 어떤 객체는 중간에 여러 객체에서 여러 번 참조될 수도 있고 특정 객체들은 순환참조 문제가 있을 수도 있기 때문에 복사 후에 약한 참조로 지정해야 하는 경우도 있다.
	- 따라서 객체 그래프가 복잡한 경우에는 **단지 깊은 복사만으로 하위 객체들의 참조 관계가 완벽하게 복사되지는 않는다.**
	- 깊은 복사 종류:
	    1. **코어 데이터**: 객체 그래프를 저장하기 위한 프레임워크
	    2. **아카이브**: 아래 설명

### 3. 아카이브
#### 객체 직렬화(plist)
- **아카이브와 마찬가지로 객체 그래프를 따라 객체의 데이터 내용을 저장하는 방식** (NSPropertyList Serialization 클래스 참고)
- 하지만 여러 곳에서 하나의 객체를 다중 참조하고 있으면, **참조마다 동일한 내용의 객체를 여러 개 저장**하고, 다시 객체화 시 다중 참조하는 형태로 복원하는 게 아니라 **각기 다른 객체로 만들어 버린다**. 또한, 데이터 값만 저장하기 때문에 만들어진 객체가 가변 객체인지 불변 객체인지 판단해서 복원할 수 없다.
- **NSDictionary, NSArray, NSString, NSDate, NSData, NSNumber 타입의 데이터 구조만**  XML 기반 프로퍼티 목록(plist) 파일로 직렬화하여 저장한다.
- **NSUserDefaults** 클래스: **사용자 설정을 저장하는 용도의 직렬화**
    - NSUserDefaults 클래스는 내부적으로 NSPropertyListSerialization을 사용. 따라서 직렬화를 지원하는 객체 클래스가 제한적.
    - 예를 들어 UIColor, NSFont 같은 타입의 경우, 직렬화 시 NSData를 사용하여 바이너리로 바꿔야 함.

#### NSCoding 프로토콜
- 가변객체나 다중 참조 관계 등을 원래대로 복원해야 하는 경우 사용
- NSCoder 클래스: 메모리상에 있는 객체 인스턴스 변수를 다른 형태로 변환하기 위한 인터페이스를 선언한 추상화 클래스로, 일부 제한된 기능만 구현되어 있으며 **실제로는 NSKeyedArchiver, NSKeyedUnarchiver, NSPortCoder 같은 하위 클래스 구현체를 사용**한다.
- 객체 그래프 복원 시 뿌리 객체(root object)와 조건부 객체(conditional objects) 개념을 사용
- **뿌리 객체**: **아카이브를 시작하는 시점**을 의미하며, 기존에 인코딩했던 객체를 다시 참조할 경우 인코딩한 기존 객체를 참조한다. (NSCoder.encodeRootObject)
- **조건부 객체**: 반드시 아카이브하지 않아도 되는 참조객체로, **소유권 관계가 명확해서 어느 시점에 반드시 인코딩이 되는 특정한 객체를 참조하기 때문에 다시 인코딩 될 필요가 없는 객체**이다. (encodeConditionalObject). 약한 참조 형태로 인코딩된다.

#### 이름있는 아카이브(Keyed Archives)
- 인스턴스 변수를 인코딩할 때 사전 타입처럼 **변수에 대한 키 값을 이름으로 지정**해서 인코딩할 수 있다. 디코딩 시엔 **키 값으로 저장한 값**을 찾아 복원한다.
- 고유한 키 값을 지정하기 위해 키 값 규칙을 정해야 한다: 단, NS, UI, $ 같은 코코아에서 쓰이는 접두어는 피한다.
- 디코딩 시, 해당하는 키 값에 대한 데이터가 없을 수도 있다. 이 때는 nil 값을 반환한다.
- **아카이브 델리게이트**: NSKeyedArchiverDelegate나 NSKeyedUnarchiverDelegate 프로토콜로 정의하여 **델리게이트를 지정해서 각 객체를 인코딩, 디코딩하는 시점에 알림을 받을 수 있다**.
- [참고] NSCoder 구현 클래스 중 NSArchiver, NSUnarchiver 클래스는 디코딩 시 인코딩한 순서와 동일하게 맞춰야 해서, 인스턴스 변수가 바뀌거나 삭제된 변경사항이 있으면 디코딩하지 못하는 경우가 있다. 따라서 인코딩/디코딩 시점에 이름을 키 값으로 사용할 수 있는 NSKeyedArchiver, NSKeyedUnarchiver 클래스를 사용하도록 권장한다.

[참고: Cocoa Internals](http://www.yes24.com/24/viewer/preview/34962602)

<br/>

### 아카이브 대안으로는?

>- 아카이브의 결점은 아카이브 안의 내용에 접근하려면 전체 파일을 언아카이빙 해야하며, 변경 사항을 저장하려면 반드시 전체 파일을 다시 써야하는 점이다.
>- 반면 코어데이터는 저장된 객체들의 일부분을 가져올 수 있으며, 어떤 객체를 변경한다면 그 파일의 해당 부분만 갱신할 수 있다. 이 경우 파일시스템과 RAM 사이를 오가는 많은 모델 객체를 가지는 경우 앱의 급격한 성능 향상을 가져올 수 있다.
>- 아카이브와 코어데이터는 데이터를 로컬에 저장한다는 공통점이 있고, 원격 서버에 데이터를 저장하길 원한다면 주로 웹 서비스를 이용한다.

[출처: Puuurm's github](https://github.com/code-squad/swift-vendingmachineapp/blob/puuurm/README.md)